---
title: "Programming Principles"
format: html
---


## Introduction

Programming plays a central role in marketing analytics. Whether we study consumer survey responses, model churn in a subscription business, or scrape product reviews from online platforms, we inevitably face the challenge of working with messy data, complex models, and the need for trustworthy results. In these settings, programming is not simply about “getting the numbers out” but about creating analyses that are correct, reproducible, and understandable for both academic and managerial audiences.

Many students first encounter marketing analytics through tools like Excel or ad-hoc scripts in R. These approaches can work for small, one-off tasks but often break down once projects grow in size or complexity. If you have to re-run an analysis next month with new sales data, or share your work with a colleague who wants to apply your method to another customer segment, suddenly it matters whether your code is systematic, reusable, and transparent. This is where programming principles become essential.

In this chapter, we focus on the principles and building blocks that underlie good programming in marketing analytics. On the one hand, we introduce habits—such as keeping raw data untouched, writing clear and readable code, and organizing files consistently—that help ensure analyses can be trusted. On the other hand, we cover the basic “grammar” of programming—variables, loops, conditionals, and functions—that make it possible to put these habits into practice.

Later, we will connect these foundations to broader scientific qualities that make analytics credible. Four ideas are especially important: reproducibility (the ability to rerun the same analysis on the same data and get the same result), replicability (whether the same analysis gives similar results on new data), robustness (whether conclusions hold across alternative methods), and generalizability (whether insights extend across contexts). These qualities go beyond writing correct code—they determine whether your work can be trusted by colleagues, applied in new settings, and built upon in research or practice.

## Core Principles of Scientific Programming

When you start programming for marketing analytics, it may be tempting to think of code as something quick and disposable: a set of commands that get you the results you need for the next assignment or project. But the reality is that code is the backbone of your analysis. Every decision you make—how you clean the data, how you run the model, how you present the results—is captured in the way you program. Unlike slides or tables, code is not just a byproduct; it is the record that shows how your results were created.

In professional settings, analysts rarely work alone. Imagine being asked to update a churn prediction model built by a colleague, or to extend an analysis to a new market. If the original code is unclear, disorganized, or missing entirely, the task becomes frustrating or even impossible. The same applies in academic research: if a study cannot be reproduced, its findings lose credibility. Good programming is therefore not only a technical skill but also a professional responsibility.

The good news is that you do not need to be an expert programmer to develop sound habits. By following a handful of principles, you can make your work more reliable, easier to share, and more valuable in the long run. Below, we introduce eight core principles, each illustrated with a short example from marketing analytics. Together, they form the foundation of credible, reproducible, and trustworthy analysis.


### Reproducibility

Last semester, a student team built a customer churn model. Their results were strong, and the company partner asked them to re-run the model with fresh data six months later. But when the students tried, they realized they had only saved their final plots and tables, not the full code and data pipeline. The model could not be reproduced. Reproducibility means that given the same data and the same code, you (or someone else) can generate the same results again. In marketing analytics, where models often need to be updated regularly, reproducibility is the bare minimum for credible work. Reproducibility is not only a technical matter but also a professional one: without it, analyses cannot be trusted, updated, or extended.

### Keep Raw Data Raw

An analyst receives customer transaction logs in Excel. To prepare the data, she deletes rows, replaces missing values, and saves the file—overwriting the original. By editing the raw file directly, the analyst lost her only source of truth. Keeping raw data raw means always storing an untouched version and doing all cleaning in code. This ensures you can always return to the original source if something goes wrong.

### Small Steps

A group of students is tasked with analyzing product reviews. They load the data, clean it, build sentiment models, and create visualizations—all in one long script. When the final plots look strange, no one can tell whether the problem lies in the cleaning, the modeling, or the plotting. Debugging becomes a nightmare. By working in small, modular steps—import, clean, analyze, visualize—errors are easier to identify and fix. Small steps also make the workflow more transparent to others.

### Clarity over Cleverness

One student finds a clever one-line command in R that condenses several cleaning steps. It works perfectly, but when she shows it to her group, no one else understands what the code is doing. Later, when the project is passed on, the new analyst struggles to maintain it. Clever code may be fun to write, but clear code is easier to read, share, and extend. In collaborative environments like marketing teams, clarity always wins over cleverness.

### Consistency and Organization

Two analysts collaborate on evaluating a marketing campaign. One names files “data1.csv,” “final.csv,” and “newfinal2.csv.” The other uses a structure with `data/raw/`, `data/processed/`, and `output/`. When merging their work, one system is far easier to navigate. Consistent file naming and folder organization reduce confusion, save time, and prevent mistakes. A well-structured project is not just tidier—it is more professional.

### Save Code, Not Just Results

A team runs a segmentation analysis and delivers polished charts for a report. Months later, their professor asks them to add one more variable to the analysis. They still have the old figures, but not the scripts that produced them. The project has to be rebuilt from scratch. Saving your code alongside your outputs means results can always be regenerated, updated, and verified. In marketing analytics, where new data arrive continuously, this practice is essential.

### Check Results

An analyst notices that the average customer lifetime value in her dataset suddenly doubles after cleaning. Instead of investigating, she presents the result. Later, it turns out she accidentally removed all customers with low purchases. A quick histogram or summary table would have exposed the error. Checking your results with simple visualizations or sanity checks is a safeguard against presenting flawed insights.

### Start Simple, Then Improve

Faced with predicting response to a new campaign, one group of students immediately dives into deep learning models. After days of tuning, the model still performs poorly. Another group begins with a simple logistic regression. Their results are clear, interpretable, and easy to present. Only after establishing a baseline do they experiment with more advanced methods. Starting simple ensures you have a working solution before adding complexity.



**In sum:** these principles may feel like common sense, but when ignored, they lead to wasted time, lost credibility, and broken analyses. By adopting them early, you will build marketing analytics projects that are reproducible, transparent, and useful not only to you but also to collaborators, managers, and future users.


::: {.callout title="Programming Principles at a Glance"}

- Keep raw data untouched.
- Always make analyses reproducible.
- Work in small, manageable steps.
- Write clear, readable code.
- Organize files and folders consistently.
- Save the code that creates your results.
- Add comments and explanations.
- Sanity-check your results before trusting them.
- Start with simple solutions, then refine.
- Treat your code as part of the science, not a throwaway tool.

:::

## Core Programming Concepts

Programming is a language. Just as you cannot write a sentence without nouns and verbs, you cannot write code without the basic building blocks of a language. These building blocks—variables, data structures, loops, conditionals, functions, and libraries—form the *grammar of programming*.

At first, they may seem abstract, but each of them solves problems that you will face almost immediately in marketing analytics. Imagine analyzing thousands of customer transactions, predicting churn, or classifying online reviews. Without these tools, you would either repeat yourself endlessly or get lost in messy scripts. With them, you can organize your work, make it efficient, and keep it understandable.

Let’s walk through these concepts one by one. Each section starts with a short story, shows code examples, and explains why the concept matters for marketing analytics.



### Variables

A marketing manager asks you: *“How many of our customers have churned this month?”* You find the number in your dataset and tell her: *“It’s 241.”* A week later she asks again. You scroll through your code, searching for the place where you typed 241, but now the number has changed, and you can’t remember what it refers to. You end up recomputing everything from scratch.

This is the problem variables solve.

__A variable gives a name to a value, so you can store it, reuse it, and update it easily. Instead of hardcoding numbers or text, you make them flexible.__

Let's illustrate this with an example:

```r
# Store a value in a variable
num_churned <- 241  

# Use it in a calculation
total_customers <- 1200
churn_rate <- num_churned / total_customers
churn_rate
```

Variables are not limited to numbers. They can store:

* **Text (character variables)**

  ```r
  campaign_name <- "Summer Promo"
  ```

* **Booleans (TRUE/FALSE values)**

  ```r
  is_active <- TRUE
  churned <- FALSE
  ```

  For example, these are particularly important in marketing analytics when creating indicators, e.g., whether a customer is loyal, whether a campaign is running, or whether a product is in stock.

* **Factors (categorical variables)**
  
  ```r
  customer_segment <- factor(c("Silver", "Gold", "Gold", "Bronze"))
  ```

  In R, factors are used to represent categories. Factors are useful for variables such as *segment*, *region*, or *channel*, because R treats them differently from text—it knows they are categories and can use them in models.

::: {.callout}
Think of variables like *labeled jars in your kitchen*. Instead of guessing which jar holds sugar, you put a label on it. You can take out sugar whenever you need it, and if you replace the sugar with flour later, the label ensures you still know what’s inside.
:::



### Data Structures


Imagine you are working on a campaign with thousands of customers. Each has an ID, a purchase history, and a churn status. If you stored each number in its own variable—`id1`, `id2`, `id3`—you’d quickly lose track. What you need is a way to group related values together.

This is what data structures provide.

__In R, data structures let you store and organize multiple values in systematic ways.__

We now discuss the most common data structures: 

* **Vectors**: sequences of values.

  ```r
  product_ids <- c("A123", "B456", "C789")
  prices <- c(9.99, 14.95, 29.90)
  ```

* **Lists**: collections that can hold different types.

  ```r
  campaign <- list(
    id = "SPRING2025",
    budget = 50000,
    channels = c("email", "social", "search")
  )
  ```

* **Data frames**: tabular data, like spreadsheets.

  ```r
  customers <- data.frame(
    id = c(1, 2, 3),
    name = c("Alice", "Bob", "Charlie"),
    purchases = c(5, 1, 8),
    churned = c(FALSE, TRUE, FALSE)
  )
  ```

Data frames are the bread and butter of marketing analytics: rows are customers, transactions, or campaigns; columns are attributes or metrics.


::: {.callout}

Think of a **vector** as a shopping list, a **list** as your whole grocery bag (with fruits, bread, and a receipt mixed together), and a **data frame** as the supermarket inventory sheet—rows for products, columns for attributes.
:::


### Loops

You’ve been asked to run a churn prediction for five countries. Your first instinct is to copy and paste the same block of code five times, changing only the country name. It works, but it’s clunky. Next week your boss says: *“Can you add Italy?”* Now you have to copy the block again, hoping you didn’t miss a line somewhere.

This is what loops are designed for.

__A loop repeats a set of instructions automatically.__

#### For-loops

A `for` loop repeats code for each element in a vector.

```r
countries <- c("NL", "DE", "FR")

for (c in countries) {
  print(paste("Running churn model for", c))
}
```

* *Input*: a vector (`countries`).
* *Process*: the loop takes one element at a time and executes the body of the loop.
* *Output*: whatever you program it to produce (e.g., print, save files, store results).

Use for-loops when you need flexibility—for example, when each iteration involves several steps (load data, fit model, save results).


#### While-loops

A `while` loop repeats as long as a condition is true.

```r
budget <- 10000

while (budget > 0) {
  print(paste("Remaining budget:", budget))
  budget <- budget - 2000
}
```

These are useful when you don’t know in advance how many repetitions are needed—for example, simulating customer arrivals until your sample size is large enough.


#### lapply()

`lapply()` applies a function to each element of a list and **returns a list**.

```r
campaigns <- list("SpringPromo", "SummerBlast", "WinterSale")

lapply(campaigns, nchar)
# Returns: list(11, 11, 10)
```

The return value is always a list, even if the function produces single numbers.

To access values from the result list, you can use:

```r
# Double brackets [[ ]] give one element
lapply(campaigns, nchar)[[1]]
# [1] 11

# Single brackets [ ] return a sublist
lapply(campaigns, nchar)[1]
# Still a list of length 1
```

This distinction is crucial:

* `[[ ]]` = extract the element itself.
* `[ ]` = keep the element wrapped in a list.


#### sapply()

`sapply()` works like `lapply()` but tries to **simplify the result** into a vector or matrix when possible.

```r
sapply(campaigns, nchar)
# Returns: c(11, 11, 10)
```

This makes it easier for quick calculations. However, if outputs are irregular, `sapply()` falls back to a list, so be mindful of what it produces.


__Why Loops Matter__

Loops turn repetitive copy-paste scripts into elegant, scalable workflows. In marketing analytics, you might use loops to:

* run churn models across multiple countries,
* apply cleaning functions to lists of customer datasets,
* calculate key performance indicators (KPIs) for dozens of campaigns.

::: {.callout}
Think of loops as an assembly line. You set up the steps once, and then each new item—be it a country, a dataset, or a campaign—goes through the same process automatically. `lapply()` and `sapply()` are just more efficient assembly lines: they stamp each item with a function and hand back the results neatly packaged.
:::

### Conditionals

You are designing a loyalty program. Customers with more than ten purchases are labeled “VIP.” Others are labeled “regular.” Writing this rule by hand for every customer would be impossible. Conditionals allow your code to make these decisions for you.

Conditionals evaluate whether something is true or false, and run code accordingly.

```r
purchases <- 5

if (purchases > 10) {
  status <- "VIP"
} else if (purchases > 0) {
  status <- "regular"
} else {
  status <- "new"
}
```

Conditionals matter because they make your analysis adaptable. For example, you might:

* apply different discount rules based on customer segment,
* treat missing data differently depending on the variable,
* show warnings if model accuracy is below a threshold.

::: {.callout}
A conditional is like a fork in the road. If the condition is met, you go left; if not, you go right. Your program takes the right path automatically.
:::



### Functions

You’ve cleaned product review data five times already this semester. Each time, you copy and paste the same five lines of code. Then, during your thesis, you discover a mistake in those lines. Now you have to fix it everywhere. Functions save you from this pain.

__A function is a reusable block of code. You define it once, and then call it whenever needed.__

```r
# Define the function
calc_discount <- function(price, discount_rate = 0.10) {
  discounted_price <- price * (1 - discount_rate)
  return(discounted_price)
}

# Call the function
calc_discount(100)      # uses default 10% discount
calc_discount(100, 0.2) # override default
```

Functions can also return multiple values:

```r
customer_summary <- function(name, purchases, spend) {
  avg_spend <- spend / purchases
  return(list(
    customer = name,
    avg_spend = avg_spend
  ))
}

customer_summary("Alice", 5, 200)
```

Functions matter because they make your code modular and reusable. For example, you might write a function `clean_reviews()` that takes raw reviews and returns cleaned text. Later, you can reuse it for different datasets without rewriting everything.

::: {.callout}
Think of a function like a kitchen appliance. Once you build it (define it), you can put in different ingredients (arguments) and always get the right output (return value).
:::


### Libraries and Packages

Suppose you want to plot churn rates across customer segments. You could try to write all the plotting commands yourself in base R, figuring out where the bars should go, how tall they should be, how to color them. Hours later, you might still have something that looks clunky. Or—you could load `ggplot2`, a package that thousands of data scientists use daily, and create a professional-looking plot in just a few lines of code.

Packages are collections of functions written by others, shared for everyone to use. They save you from reinventing the wheel and let you build on reliable, well-tested tools.

#### Installing and loading packages

In R, you install a package once, and then load it each time you start a session:

```r
# Install once (downloads the package from CRAN)
install.packages("ggplot2")

# Load it every time you need it
library(ggplot2)
```

After loading, you can access all of the functions in the package.

#### ggplot2 for visualization

One of the most important packages you’ll use is **ggplot2**, the standard for creating plots in R. It follows the “grammar of graphics,” where you build plots layer by layer.

```r
# Example: plot purchases vs churn
customers <- data.frame(
  purchases = c(2, 5, 8, 1, 6),
  churned = c(TRUE, FALSE, FALSE, TRUE, FALSE)
)

library(ggplot2)

ggplot(customers, aes(x = purchases, y = churned)) +
  geom_point()
```

This short script gives you a scatterplot. By adding layers (`+ geom_smooth()`, `+ facet_wrap()`), you can extend the plot easily.

For marketing analytics, `ggplot2` is invaluable: visualize campaign responses, customer journeys, or product sales at a glance.


#### The tidyverse and dplyr for data wrangling

Visualization is only half the story. Most of your time as an analyst is spent cleaning and transforming data. For this, R’s **tidyverse** provides powerful tools, especially the `dplyr` package.

Install the tidyverse once:

```r
install.packages("tidyverse")
```

Load it at the start of your session:

```r
library(tidyverse)
```

Now you can use `dplyr` verbs like `filter()`, `select()`, `mutate()`, `group_by()`, and `summarise()` to wrangle data frames in a clear, readable way.

```r
# Example: calculate churn rate by number of purchases
customers %>%
  group_by(purchases) %>%
  summarise(churn_rate = mean(churned))
```

The `%>%` (pipe) operator passes the data from one step to the next, letting you chain transformations in a logical sequence.

::: {.callout-note title="Pipes vs. Nested Function Calls"}

There are two common ways to chain commands in R.

**Nested function calls (sometimes nicknamed “onion coding”):**

```r
# Wrapping functions inside each other
mean(log(sqrt(customers$purchases)))
```

This works, but it is hard to read. You have to start in the middle (`customers$purchases`) and peel outward layer by layer, like an onion.

**Pipe coding (`%>%`):**

```r
# Using pipes makes the sequence explicit
customers %>%
  mutate(purchases_sqrt = sqrt(purchases)) %>%
  mutate(purchases_log = log(purchases_sqrt)) %>%
  summarise(mean_log_sqrt = mean(purchases_log))
```

Here, the steps are written in the order they happen: take the data → transform it → summarize it.

Pipes make your analysis a *clear sequence of operations*. Nested calls force readers to reverse-engineer the order by peeling inward. In marketing analytics, where workflows often involve multiple transformations (cleaning, filtering, aggregating), the pipe is almost always easier to read, debug, and share.

:::



#### Why packages matter

Packages like **ggplot2** and **dplyr** are the daily workhorses of marketing analytics. They:

* Save time by providing ready-made tools.
* Improve reliability by using widely tested methods.
* Make code more readable and professional.
* Allow you to move quickly from raw customer data to clean, visual insights.


::: {.callout}
Think of packages like apps on your phone. You don’t build your own navigation system; you install Google Maps. You don’t write your own music player; you install Spotify. In the same way, analysts don’t code every graph or transformation from scratch—they install and use packages.
:::


Together, these concepts—-variables, data structures, loops, conditionals, functions, and libraries—-are the grammar of programming. Mastering them is like learning how to form sentences: they are the foundation for everything you will do in marketing analytics.

## Environments and Formats

R programming can be done in several ways, and the choices you make affect how easily your work can be developed, shared, and reproduced. In this section we distinguish between the environments in which you write and run R, and the file formats you use to save and communicate your work.

### Environments

#### R

At its core, R is a programming language and interpreter. If you install only R, you interact with it through a command-line console: type a command, press enter, and R executes it. This environment is minimal. It is sufficient for quick checks or very small tasks, but for real projects it quickly becomes cumbersome. Most analysts therefore rely on richer interfaces built on top of R.

#### RStudio

RStudio (now called *Posit RStudio*) is the most widely used integrated development environment (IDE) for R. It combines a script editor, console, workspace viewer, and plot window in a single interface. It also provides project management, package installation tools, and integrated support for R Markdown and Quarto.

RStudio is the standard environment for learning R and remains the daily workhorse for many analysts and researchers. It makes R more approachable and productive, while still running the same R code that the plain interpreter would execute.

#### Visual Studio Code (VS Code)

Visual Studio Code is a general-purpose code editor developed by Microsoft. Unlike RStudio, it is not designed specifically for R, but it supports many languages (R, Python, Julia, SQL, and more) through extensions. With the **R extension for VS Code**, you can edit and run R scripts, view data frames, and use the integrated terminal.

VS Code is particularly useful in settings where you work across multiple languages or need to integrate R into larger software development workflows. For example, if you are developing an automated marketing analytics pipeline that combines R (for modeling), Python (for scraping), and SQL (for databases), VS Code allows you to manage everything in one environment.

RStudio remains the natural starting point for most students in marketing analytics. VS Code becomes relevant when projects grow in complexity or when you want to align your workflow with professional software development practices. Both rely on the same underlying R engine, so the code you write in one environment can be run in the other without modification.

### Formats

#### R Scripts (`.R`)

An R script is a plain text file that contains code only. Scripts are the basic building block for analyses: you can open them in RStudio, run them line by line while exploring, or execute them from start to finish. Scripts are also modular—you might have one script to clean data, another to run a model, and a third to produce plots.

```r
# analysis.R
customers <- read.csv("data/customers.csv")
mean(customers$purchases)
```

From the command line you can run:

```bash
Rscript analysis.R
```

Scripts are flexible and reliable, making them the backbone of most projects.

#### R Markdown (`.Rmd`)

R Markdown combines narrative text with code and output in a single document. Instead of keeping code and interpretation separate, you explain your steps in prose, show the code, and include the results directly below it.

```yaml
    ---
    title: "Churn Report"
    output: html_document
    ---
    
    This report analyzes customer churn.
   
    ```r
    customers <- read.csv("data/customers.csv")
    mean(customers$churned)
    ```

```
*Important: Note that in the code box above, `r` needs to be wrapped in `{}` &rarr; `{r}` to work properly.*

Knitting this file produces an HTML or PDF report that shows text, code, and results together. R Markdown is widely used for reproducible reports, assignments, and technical documentation. To use it, you need the `rmarkdown` and `knitr` packages.  


### Quarto (`.qmd`)  

Quarto is the modern successor to R Markdown. It works in the same spirit but supports a wider range of outputs, including reports, presentations, websites, and books. Quarto is what we use to write this textbook.  

````yaml
---
title: "Campaign Analysis"
format: html
---

This report analyzes campaign effectiveness.

```r
campaigns <- read.csv("data/campaigns.csv")
summary(campaigns$response_rate)
```

````
*Important: Note that in the code box above, `r` needs to be wrapped in `{}` &rarr; `{r}` to work properly.*

Quarto is installed separately, but once set up, it integrates smoothly with RStudio. To render documents from the command line, use:  

```bash
quarto render report.qmd
```


### Running your code

You can run R in interactive mode or non-interactive mode.

**Interactive (RStudio).** This is where most students begin. You can run lines one by one, immediately inspect results, and view plots. Interactive work is great for exploration, but it can also create hidden steps—you may forget which commands you executed, making it harder to reproduce later.

**Non-interactive (command line).** From the terminal, you can execute R scripts from start to finish, ensuring that every step is run in the correct order. This is essential for automation.

* Run a script:

  ```bash
  Rscript analysis.R
  ```

* Run R with a clean environment:

  ```bash
  R --vanilla < analysis.R
  ```

  The `--vanilla` option ignores saved objects and history, which reduces the risk of hidden dependencies.

* Pass arguments to a script:

  ```r
  # analysis.R
  args <- commandArgs(trailingOnly = TRUE)
  dataset <- args[1]
  data <- read.csv(dataset)
  print(summary(data))
  ```

  Run it with:

  ```bash
  Rscript analysis.R data/customers.csv
  ```

This approach makes scripts flexible and easy to reuse across datasets or projects.

Together, these formats and environments give you different ways of working with R. Scripts provide the backbone, R Markdown and Quarto make results readable and shareable, RStudio gives you an interactive workspace, and the command line ensures automation and reproducibility.

## Connecting Principles and Concepts: A Roadmap

Principles and concepts are two sides of the same coin. Principles describe good habits—keep raw data raw, avoid repeating yourself, check results. Concepts provide the grammar of R—variables, loops, conditionals, functions, and libraries. Environments and formats (scripts, R Markdown, Quarto, RStudio, command line) are where these habits and tools come together.

The following Table illustrates how principles connect to programming concepts, with examples from marketing analytics. The mapping is not perfect—there are many ways to realize a principle in code—but it shows how habits and tools reinforce each other in practice.

| **Principle (habit)**       | **Programming concept**        | **Marketing analytics example**                                                |
| --------------------------- | ------------------------------ | ------------------------------------------------------------------------------ |
| Don’t repeat yourself       | Variables, loops, functions    | Store a churn threshold once in a variable; loop over multiple countries.      |
| Keep raw data raw           | Data structures, file handling | Keep untouched transaction logs in `data/raw/`, work with cleaned data frames. |
| Work in small steps         | Functions, scripts             | Write `clean_reviews()` once and reuse it across scripts.                      |
| Clarity over cleverness     | Variables, conditionals        | Use `customer_status <- "loyal"` instead of a dense one-liner.                 |
| Stay consistent             | Libraries/packages             | Use `dplyr` for wrangling and `ggplot2` for plotting across projects.          |
| Save code, not just results | R scripts, R Markdown, Quarto  | Share a `.qmd` report so colleagues can regenerate churn analysis.             |
| Always check results        | Conditionals, visualization    | Add `if` checks for missing values; plot churn by segment.                     |
| Start simple, then improve  | Functions, libraries           | Begin with logistic regression, then extend with a specialized machine learning package like `caret`.  |

The table makes clear that principles are not only abstract advice: they become actionable through programming concepts. “Don’t repeat yourself” is realized when loops or functions replace copy-pasted code. “Keep raw data raw” is reinforced by separating raw and processed files and storing cleaned data in data frames. “Save code, not just results” finds its natural home in R scripts, R Markdown, and Quarto—formats that preserve not just outputs but the full chain of analysis.

And let's not forget about environments and formats: Scripts are well suited for implementing small functions and loops; R Markdown and Quarto support clarity and transparency by weaving code with narrative. RStudio is an ideal place for exploring and checking results, while the command line strengthens reproducibility by running scripts from start to finish without hidden steps.

The mapping is flexible, but the lesson is clear: good habits (principles), the grammar of R (concepts), and the right formats and environments work together to create analyses that are reproducible, transparent, and professional.

